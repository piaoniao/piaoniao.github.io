<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Effective C# 读书笔记 | PiaoNiao&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="PS：本文只是读书笔记，详细资料建议看书 C# 语言的编程习惯第 1 条：优先使用隐式类型的局部变量 局部变量可用 var 来声明，让编译器自动选择合适的类型  不推荐用 var 声明数值类型的变量（精度转换问题）   第 2 条：考虑用 readonly 代替 const readonly：声明运行期常量  const：声明编译期常量；只有当程序性能极端重要且常量取值不会随版本而变化的情况下，才">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective C# 读书笔记">
<meta property="og:url" content="https://github.com/piaoniao/2018/10/11/effective-csharp/index.html">
<meta property="og:site_name" content="PiaoNiao&#39;s Blog">
<meta property="og:description" content="PS：本文只是读书笔记，详细资料建议看书 C# 语言的编程习惯第 1 条：优先使用隐式类型的局部变量 局部变量可用 var 来声明，让编译器自动选择合适的类型  不推荐用 var 声明数值类型的变量（精度转换问题）   第 2 条：考虑用 readonly 代替 const readonly：声明运行期常量  const：声明编译期常量；只有当程序性能极端重要且常量取值不会随版本而变化的情况下，才">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-10-22T01:16:16.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Effective C# 读书笔记">
<meta name="twitter:description" content="PS：本文只是读书笔记，详细资料建议看书 C# 语言的编程习惯第 1 条：优先使用隐式类型的局部变量 局部变量可用 var 来声明，让编译器自动选择合适的类型  不推荐用 var 声明数值类型的变量（精度转换问题）   第 2 条：考虑用 readonly 代替 const readonly：声明运行期常量  const：声明编译期常量；只有当程序性能极端重要且常量取值不会随版本而变化的情况下，才">
  
    <link rel="alternate" href="/atom.xml" title="PiaoNiao&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">PiaoNiao&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/piaoniao"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-effective-csharp" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/11/effective-csharp/" class="article-date">
  <time datetime="2018-10-11T13:49:27.000Z" itemprop="datePublished">2018-10-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Effective C# 读书笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>PS：本文只是读书笔记，详细资料建议看书</p>
<h2 id="C-语言的编程习惯"><a href="#C-语言的编程习惯" class="headerlink" title="C# 语言的编程习惯"></a>C# 语言的编程习惯</h2><h3 id="第-1-条：优先使用隐式类型的局部变量"><a href="#第-1-条：优先使用隐式类型的局部变量" class="headerlink" title="第 1 条：优先使用隐式类型的局部变量"></a>第 1 条：优先使用隐式类型的局部变量</h3><ul>
<li><p>局部变量可用 <code>var</code> 来声明，让编译器自动选择合适的类型</p>
</li>
<li><p>不推荐用 <code>var</code> 声明数值类型的变量（精度转换问题）</p>
</li>
</ul>
<h3 id="第-2-条：考虑用-readonly-代替-const"><a href="#第-2-条：考虑用-readonly-代替-const" class="headerlink" title="第 2 条：考虑用 readonly 代替 const"></a>第 2 条：考虑用 readonly 代替 const</h3><ul>
<li><p>readonly：声明运行期常量</p>
</li>
<li><p>const：声明编译期常量；只有当程序性能极端重要且常量取值不会随版本而变化的情况下，才可以考虑使用</p>
</li>
</ul>
<h3 id="第-3-条：优先考虑-is-或-as-运算符，尽量少用强制类型转换"><a href="#第-3-条：优先考虑-is-或-as-运算符，尽量少用强制类型转换" class="headerlink" title="第 3 条：优先考虑 is 或 as 运算符，尽量少用强制类型转换"></a>第 3 条：优先考虑 is 或 as 运算符，尽量少用强制类型转换</h3><h3 id="第-4-条：用内插字符串取代-string-Format"><a href="#第-4-条：用内插字符串取代-string-Format" class="headerlink" title="第 4 条：用内插字符串取代 string.Format()"></a>第 4 条：用内插字符串取代 string.Format()</h3><p>个人觉得使用时要注意代码简洁</p>
<h3 id="第-5-条：用-FormattableString-取代专门为特定区域而写的字符串"><a href="#第-5-条：用-FormattableString-取代专门为特定区域而写的字符串" class="headerlink" title="第 5 条：用 FormattableString 取代专门为特定区域而写的字符串"></a>第 5 条：用 FormattableString 取代专门为特定区域而写的字符串</h3><h3 id="第-6-条：不要用表示符号名称的硬字符串来调用-API"><a href="#第-6-条：不要用表示符号名称的硬字符串来调用-API" class="headerlink" title="第 6 条：不要用表示符号名称的硬字符串来调用 API"></a>第 6 条：不要用表示符号名称的硬字符串来调用 API</h3><ul>
<li><code>nameof()</code> 方法</li>
</ul>
<h3 id="第-7-条：用委托表示回调"><a href="#第-7-条：用委托表示回调" class="headerlink" title="第 7 条：用委托表示回调"></a>第 7 条：用委托表示回调</h3><ul>
<li>注意：所有的委托都是多播委托（multicast delegate）<ul>
<li>多播委托调用目标函数时不捕获异常，因此只要有一个目标函数抛出异常，调用链就会中断</li>
<li>多播委托的执行结果是最后调用的目标函数的返回值，因此当返回值不是 Void 时，可用 <code>.GetInvocationList()</code> 迭代返回值</li>
</ul>
</li>
</ul>
<h3 id="第-8-条：用-null-条件运算符调用事件处理程序"><a href="#第-8-条：用-null-条件运算符调用事件处理程序" class="headerlink" title="第 8 条：用 null 条件运算符调用事件处理程序"></a>第 8 条：用 null 条件运算符调用事件处理程序</h3><ul>
<li>采用 <code>null</code> 条件运算符（<code>?.</code>）能线程安全地调用事件处理程序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 声明 Updated 为委托或事件，可为空</span><br><span class="line"></span><br><span class="line">// 可能空引用异常</span><br><span class="line">Updated()；</span><br><span class="line"></span><br><span class="line">// 非线程安全</span><br><span class="line">if(Updated != null) Updated();</span><br><span class="line"></span><br><span class="line">// 线程安全，但难理解</span><br><span class="line">var handler = Updated;</span><br><span class="line">if(handler != null) handler();</span><br><span class="line"></span><br><span class="line">// 线程安全</span><br><span class="line">Updated?.Invoke();</span><br></pre></td></tr></table></figure>
<h3 id="第-9-条：尽量避免装箱与取消装箱"><a href="#第-9-条：尽量避免装箱与取消装箱" class="headerlink" title="第 9 条：尽量避免装箱与取消装箱"></a>第 9 条：尽量避免装箱与取消装箱</h3><ul>
<li><p>尽量不要在需要使用 <code>System.Object</code> 的地方直接使用值类型的值</p>
</li>
<li><p>可使用 <code>.ToString()</code> 明确把值类型转换成字符串</p>
</li>
</ul>
<h3 id="第-10-条：只有在新版基类与现有子类之间的冲突时才应该使用-new-修饰符"><a href="#第-10-条：只有在新版基类与现有子类之间的冲突时才应该使用-new-修饰符" class="headerlink" title="第 10 条：只有在新版基类与现有子类之间的冲突时才应该使用 new 修饰符"></a>第 10 条：只有在新版基类与现有子类之间的冲突时才应该使用 new 修饰符</h3><ul>
<li><p><code>new</code> 修饰符可以重新定义从基类继承下来的非虚成员，但要慎用（不推荐用）</p>
</li>
<li><p>使用 <code>new</code> 修饰符是为了解决新版基类和现有子类之间的冲突</p>
</li>
</ul>
<h2 id="NET-的资源管理"><a href="#NET-的资源管理" class="headerlink" title=".NET 的资源管理"></a>.NET 的资源管理</h2><h3 id="第-11-条：理解并善用-NET-的资源管理机制"><a href="#第-11-条：理解并善用-NET-的资源管理机制" class="headerlink" title="第 11 条：理解并善用 .NET 的资源管理机制"></a>第 11 条：理解并善用 .NET 的资源管理机制</h3><ul>
<li>理解 C# GC</li>
</ul>
<h3 id="第-12-条：声明字段时，尽量直接为其设定初始值"><a href="#第-12-条：声明字段时，尽量直接为其设定初始值" class="headerlink" title="第 12 条：声明字段时，尽量直接为其设定初始值"></a>第 12 条：声明字段时，尽量直接为其设定初始值</h3><ul>
<li><p>声明成员变量并直接把它的初始值写出来</p>
</li>
<li><p>不应该编写初始化语句的情况：</p>
<ul>
<li>把对象初始化为 0 或 null</li>
<li><p>不同的构造函数需要根据各自的方式来设定某个字段的初始值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass2</span><br><span class="line">&#123;</span><br><span class="line">   	private List&lt;string&gt; labels = new List&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">   	MyClass2()</span><br><span class="line">   	&#123;</span><br><span class="line">       </span><br><span class="line">   	&#125;</span><br><span class="line"></span><br><span class="line">   	MyClass2(int size)</span><br><span class="line">   	&#123;</span><br><span class="line">       	labels = new List&lt;string&gt;(size);</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化变量的过程中有可能出现异常</p>
</li>
</ul>
</li>
</ul>
<h3 id="第-13-条：用适当的方式初始化类中的静态成员"><a href="#第-13-条：用适当的方式初始化类中的静态成员" class="headerlink" title="第 13 条：用适当的方式初始化类中的静态成员"></a>第 13 条：用适当的方式初始化类中的静态成员</h3><ul>
<li>静态构造函数</li>
</ul>
<h3 id="第-14-条：尽量删减重复的初始化逻辑"><a href="#第-14-条：尽量删减重复的初始化逻辑" class="headerlink" title="第 14 条：尽量删减重复的初始化逻辑"></a>第 14 条：尽量删减重复的初始化逻辑</h3><h3 id="第-15-条：不要创建无谓的对象"><a href="#第-15-条：不要创建无谓的对象" class="headerlink" title="第 15 条：不要创建无谓的对象"></a>第 15 条：不要创建无谓的对象</h3><ul>
<li>频繁使用的对象的复用</li>
</ul>
<h3 id="第-16-条：绝对不要在构造函数里面调用虚函数"><a href="#第-16-条：绝对不要在构造函数里面调用虚函数" class="headerlink" title="第 16 条：绝对不要在构造函数里面调用虚函数"></a>第 16 条：绝对不要在构造函数里面调用虚函数</h3><p>在（基类的）构造函数里面调用虚函数会令代码严重依赖于派生类的实现细节，而这些细节是无法控制的</p>
<h3 id="第-17-条：实现标准的-dispose-模式"><a href="#第-17-条：实现标准的-dispose-模式" class="headerlink" title="第 17 条：实现标准的 dispose 模式"></a>第 17 条：实现标准的 dispose 模式</h3><h2 id="合理地运用泛型"><a href="#合理地运用泛型" class="headerlink" title="合理地运用泛型"></a>合理地运用泛型</h2><p>封闭式泛型类型 VS 开放式泛型类型</p>
<p>类型参数是引用类型 VS 类型参数是值类型</p>
<h3 id="第-18-条：只定义刚好够用的约束条件"><a href="#第-18-条：只定义刚好够用的约束条件" class="headerlink" title="第 18 条：只定义刚好够用的约束条件"></a>第 18 条：只定义刚好够用的约束条件</h3><h3 id="第-19-条：通过运行期类型检查实现特定的泛型算法"><a href="#第-19-条：通过运行期类型检查实现特定的泛型算法" class="headerlink" title="第 19 条：通过运行期类型检查实现特定的泛型算法"></a>第 19 条：通过运行期类型检查实现特定的泛型算法</h3><h3 id="第-20-条：通过-IComparable-及-IComparer-定义顺序关系"><a href="#第-20-条：通过-IComparable-及-IComparer-定义顺序关系" class="headerlink" title="第 20 条：通过 IComparable 及 IComparer 定义顺序关系"></a>第 20 条：通过 IComparable<t> 及 IComparer<t> 定义顺序关系</t></t></h3><h3 id="第-21-条：创建泛型类时，总是应该给实现了-IDisposable-的类型参数提供支持"><a href="#第-21-条：创建泛型类时，总是应该给实现了-IDisposable-的类型参数提供支持" class="headerlink" title="第 21 条：创建泛型类时，总是应该给实现了 IDisposable 的类型参数提供支持"></a>第 21 条：创建泛型类时，总是应该给实现了 IDisposable 的类型参数提供支持</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T driver = new T();</span><br><span class="line">using (driver as IDisposable)</span><br><span class="line">&#123;</span><br><span class="line">    driver.DoWork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第-22-条：考虑支持泛型协变与逆变"><a href="#第-22-条：考虑支持泛型协变与逆变" class="headerlink" title="第 22 条：考虑支持泛型协变与逆变"></a>第 22 条：考虑支持泛型协变与逆变</h3><p>关键字：<code>in</code> VS <code>out</code></p>
<h3 id="第-23-条：用委托要求类型参数必须提供某种方法"><a href="#第-23-条：用委托要求类型参数必须提供某种方法" class="headerlink" title="第 23 条：用委托要求类型参数必须提供某种方法"></a>第 23 条：用委托要求类型参数必须提供某种方法</h3><h3 id="第-24-条：如果有泛型方法，就不要再创建针对基类或接口的重载版本"><a href="#第-24-条：如果有泛型方法，就不要再创建针对基类或接口的重载版本" class="headerlink" title="第 24 条：如果有泛型方法，就不要再创建针对基类或接口的重载版本"></a>第 24 条：如果有泛型方法，就不要再创建针对基类或接口的重载版本</h3><h3 id="第-25-条：如果不需要把类型参数所表示的对象设为实例字段，那么应该优先考虑创建泛型方法，而不是泛型类"><a href="#第-25-条：如果不需要把类型参数所表示的对象设为实例字段，那么应该优先考虑创建泛型方法，而不是泛型类" class="headerlink" title="第 25 条：如果不需要把类型参数所表示的对象设为实例字段，那么应该优先考虑创建泛型方法，而不是泛型类"></a>第 25 条：如果不需要把类型参数所表示的对象设为实例字段，那么应该优先考虑创建泛型方法，而不是泛型类</h3><p>如果某个类型拥有类型级别的数据成员，那么应该实现成泛型类（尤其是当成员的类型与泛型的类型有关时更应该这样做），反之，则应该实现成泛型方法。</p>
<p>如：静态工具类</p>
<h3 id="第-26-条：实现泛型接口的同时，还应该实现非泛型接口"><a href="#第-26-条：实现泛型接口的同时，还应该实现非泛型接口" class="headerlink" title="第 26 条：实现泛型接口的同时，还应该实现非泛型接口"></a>第 26 条：实现泛型接口的同时，还应该实现非泛型接口</h3><p>适用于三项内容：</p>
<ul>
<li>要编写的类以及这些类所支持的接口</li>
<li>public 属性</li>
<li>打算序列化的那些元素</li>
</ul>
<h3 id="第-27-条：只把必备的契约定义在接口中，把其他功能留给扩展方法去实现"><a href="#第-27-条：只把必备的契约定义在接口中，把其他功能留给扩展方法去实现" class="headerlink" title="第 27 条：只把必备的契约定义在接口中，把其他功能留给扩展方法去实现"></a>第 27 条：只把必备的契约定义在接口中，把其他功能留给扩展方法去实现</h3><h3 id="第-28-条：考虑通过扩展方法增强已构造类型的功能"><a href="#第-28-条：考虑通过扩展方法增强已构造类型的功能" class="headerlink" title="第 28 条：考虑通过扩展方法增强已构造类型的功能"></a>第 28 条：考虑通过扩展方法增强已构造类型的功能</h3><h2 id="合理地运用-LINQ"><a href="#合理地运用-LINQ" class="headerlink" title="合理地运用 LINQ"></a>合理地运用 LINQ</h2><h3 id="第-29-条：优先考虑提供迭代器方法，而不要返回集合"><a href="#第-29-条：优先考虑提供迭代器方法，而不要返回集合" class="headerlink" title="第 29 条：优先考虑提供迭代器方法，而不要返回集合"></a>第 29 条：优先考虑提供迭代器方法，而不要返回集合</h3><h3 id="第-30-条：优先考虑通过查询语句来编写代码，而不要使用循环语句"><a href="#第-30-条：优先考虑通过查询语句来编写代码，而不要使用循环语句" class="headerlink" title="第 30 条：优先考虑通过查询语句来编写代码，而不要使用循环语句"></a>第 30 条：优先考虑通过查询语句来编写代码，而不要使用循环语句</h3><p>声明式模型 VS 命令式模型</p>
<p>与采用循环语句所编写的命令式结构相比，查询语句（也包括实现了查询表达式模式的查询方法）能够更为清晰地表达开发者的想法</p>
<h3 id="第-31-条：把针对序列的-API-设计得更加易于拼接"><a href="#第-31-条：把针对序列的-API-设计得更加易于拼接" class="headerlink" title="第 31 条：把针对序列的 API 设计得更加易于拼接"></a>第 31 条：把针对序列的 API 设计得更加易于拼接</h3><h3 id="第-32-条：将迭代逻辑与操作、谓词及函数解耦"><a href="#第-32-条：将迭代逻辑与操作、谓词及函数解耦" class="headerlink" title="第 32 条：将迭代逻辑与操作、谓词及函数解耦"></a>第 32 条：将迭代逻辑与操作、谓词及函数解耦</h3><h3 id="第-33-条：等真正用到序列中的元素时再去生成"><a href="#第-33-条：等真正用到序列中的元素时再去生成" class="headerlink" title="第 33 条：等真正用到序列中的元素时再去生成"></a>第 33 条：等真正用到序列中的元素时再去生成</h3><h3 id="第-34-条：考虑通过函数参数来放松耦合关系"><a href="#第-34-条：考虑通过函数参数来放松耦合关系" class="headerlink" title="第 34 条：考虑通过函数参数来放松耦合关系"></a>第 34 条：考虑通过函数参数来放松耦合关系</h3><h3 id="第-35-条：绝对不要重载扩展方法"><a href="#第-35-条：绝对不要重载扩展方法" class="headerlink" title="第 35 条：绝对不要重载扩展方法"></a>第 35 条：绝对不要重载扩展方法</h3><h3 id="第-36-条：理解查询表达式与方法调用之间的映射关系"><a href="#第-36-条：理解查询表达式与方法调用之间的映射关系" class="headerlink" title="第 36 条：理解查询表达式与方法调用之间的映射关系"></a>第 36 条：理解查询表达式与方法调用之间的映射关系</h3><h3 id="第-37-条：尽量采用惰性求值的方式来查询，而不要及早求值"><a href="#第-37-条：尽量采用惰性求值的方式来查询，而不要及早求值" class="headerlink" title="第 37 条：尽量采用惰性求值的方式来查询，而不要及早求值"></a>第 37 条：尽量采用惰性求值的方式来查询，而不要及早求值</h3><h3 id="第-38-条：考虑用-lambda-表达式来替代方法"><a href="#第-38-条：考虑用-lambda-表达式来替代方法" class="headerlink" title="第 38 条：考虑用 lambda 表达式来替代方法"></a>第 38 条：考虑用 lambda 表达式来替代方法</h3><h3 id="第-39-条：不要在-Func-与-Action-中抛出异常"><a href="#第-39-条：不要在-Func-与-Action-中抛出异常" class="headerlink" title="第 39 条：不要在 Func 与 Action 中抛出异常"></a>第 39 条：不要在 Func 与 Action 中抛出异常</h3><h3 id="第-40-条：掌握尽早执行与延迟执行之间的区别"><a href="#第-40-条：掌握尽早执行与延迟执行之间的区别" class="headerlink" title="第 40 条：掌握尽早执行与延迟执行之间的区别"></a>第 40 条：掌握尽早执行与延迟执行之间的区别</h3><h3 id="第-41-条：不要把开销大的资源捕获到闭包中"><a href="#第-41-条：不要把开销大的资源捕获到闭包中" class="headerlink" title="第 41 条：不要把开销大的资源捕获到闭包中"></a>第 41 条：不要把开销大的资源捕获到闭包中</h3><h3 id="第-42-条：注意-IEnumerable-与-IQueryable-形式的数据源之间的区别"><a href="#第-42-条：注意-IEnumerable-与-IQueryable-形式的数据源之间的区别" class="headerlink" title="第 42 条：注意 IEnumerable 与 IQueryable 形式的数据源之间的区别"></a>第 42 条：注意 IEnumerable 与 IQueryable 形式的数据源之间的区别</h3><p><code>AsQueryable()</code></p>
<h3 id="第-43-条：用-Single-及-First-来明确地验证你对查询结果所做的假设"><a href="#第-43-条：用-Single-及-First-来明确地验证你对查询结果所做的假设" class="headerlink" title="第 43 条：用 Single() 及 First() 来明确地验证你对查询结果所做的假设"></a>第 43 条：用 Single() 及 First() 来明确地验证你对查询结果所做的假设</h3><h3 id="第-44-条：不要修改绑定变量"><a href="#第-44-条：不要修改绑定变量" class="headerlink" title="第 44 条：不要修改绑定变量"></a>第 44 条：不要修改绑定变量</h3><h2 id="合理地运用异常"><a href="#合理地运用异常" class="headerlink" title="合理地运用异常"></a>合理地运用异常</h2><h3 id="第-45-条：考虑在方法约定遭到违背时抛出异常"><a href="#第-45-条：考虑在方法约定遭到违背时抛出异常" class="headerlink" title="第 45 条：考虑在方法约定遭到违背时抛出异常"></a>第 45 条：考虑在方法约定遭到违背时抛出异常</h3><h3 id="第-46-条：利用-using-与-try-finally-来理清资源"><a href="#第-46-条：利用-using-与-try-finally-来理清资源" class="headerlink" title="第 46 条：利用 using 与 try/finally 来理清资源"></a>第 46 条：利用 using 与 try/finally 来理清资源</h3><h3 id="第-47-条：专门针对应用程序创建异常"><a href="#第-47-条：专门针对应用程序创建异常" class="headerlink" title="第 47 条：专门针对应用程序创建异常"></a>第 47 条：专门针对应用程序创建异常</h3><h3 id="第-48-条：优先考虑做出强异常保证"><a href="#第-48-条：优先考虑做出强异常保证" class="headerlink" title="第 48 条：优先考虑做出强异常保证"></a>第 48 条：优先考虑做出强异常保证</h3><h3 id="第-49-条：考虑用异常筛选器来改写先捕获异常再重新抛出的逻辑"><a href="#第-49-条：考虑用异常筛选器来改写先捕获异常再重新抛出的逻辑" class="headerlink" title="第 49 条：考虑用异常筛选器来改写先捕获异常再重新抛出的逻辑"></a>第 49 条：考虑用异常筛选器来改写先捕获异常再重新抛出的逻辑</h3><h3 id="第-50-条：合理利用异常筛选器的副作用来实现某些效果"><a href="#第-50-条：合理利用异常筛选器的副作用来实现某些效果" class="headerlink" title="第 50 条：合理利用异常筛选器的副作用来实现某些效果"></a>第 50 条：合理利用异常筛选器的副作用来实现某些效果</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/piaoniao/2018/10/11/effective-csharp/" data-id="cjpqps77q0001oug0jthvh9jh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/10/25/unirx/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          UniRx 学习 —— 进阶
        
      </div>
    </a>
  
  
    <a href="/2018/09/28/csharp-closure-capture/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">C# —— Closure Capture（闭包捕获）</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UniRx/">UniRx</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C#</a> <a href="/tags/UniRx/" style="font-size: 10px;">UniRx</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/03/noise/">噪声</a>
          </li>
        
          <li>
            <a href="/2018/10/31/unirx-async/">UniRx——Async</a>
          </li>
        
          <li>
            <a href="/2018/10/25/unirx/">UniRx 学习 —— 进阶</a>
          </li>
        
          <li>
            <a href="/2018/10/11/effective-csharp/">Effective C# 读书笔记</a>
          </li>
        
          <li>
            <a href="/2018/09/28/csharp-closure-capture/">C# —— Closure Capture（闭包捕获）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 PiaoNiao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>